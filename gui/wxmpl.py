#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.9.6 on Thu Jul 23 10:00:00 2020
#

import wx

# begin wxGlade: dependencies
# end wxGlade

# begin wxGlade: extracode
import matplotlib_canvas
import struct
import numpy as np
import pandas as pd
import pymongo
from scipy.fftpack import fft, ifft, hilbert
from matplotlib.backends.backend_wxagg import NavigationToolbar2WxAgg
# end wxGlade


class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: MyFrame.__init__
        kwds["style"] = kwds.get("style", 0) | wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.SetSize((1000, 800))
        
        # Menu Bar
        self.frame_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, u"设置", u"选项设置")
        self.Bind(wx.EVT_MENU, self.hello, id=item.GetId())
        self.frame_menubar.Append(wxglade_tmp_menu, u"文件")
        wxglade_tmp_menu = wx.Menu()
        item = wxglade_tmp_menu.Append(wx.ID_ANY, u"关于", u"关于本软件")
        self.Bind(wx.EVT_MENU, self.about, id=item.GetId())
        self.frame_menubar.Append(wxglade_tmp_menu, u"帮助")
        self.SetMenuBar(self.frame_menubar)
        # Menu Bar end
        self.frame_statusbar = self.CreateStatusBar(1)
        
        # Tool Bar
        self.frame_toolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.frame_toolbar)
        self.frame_toolbar.AddTool(1001, "Home", wx.Bitmap("C:\\Users\\Admin\\Desktop\\home.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Home", "")
        self.frame_toolbar.AddTool(1002, "Back", wx.Bitmap("C:\\Users\\Admin\\Desktop\\home.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Back", "")
        self.frame_toolbar.AddTool(1003, "Forward", wx.Bitmap("C:\\Users\\Admin\\Desktop\\home.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Forward", "")
        self.frame_toolbar.AddTool(1004, "Move", wx.Bitmap("C:\\Users\\Admin\\Desktop\\home.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Move", "")
        self.frame_toolbar.AddTool(1005, "Zoom", wx.Bitmap("C:\\Users\\Admin\\Desktop\\home.png", wx.BITMAP_TYPE_ANY), wx.NullBitmap, wx.ITEM_NORMAL, "Zoom", "")
        # Tool Bar end
        self.window_1 = wx.SplitterWindow(self, wx.ID_ANY)
        self.window_1_pane_1 = wx.ScrolledWindow(self.window_1, wx.ID_ANY, style=wx.TAB_TRAVERSAL)
        self.tree_ctrl_1 = wx.TreeCtrl(self.window_1_pane_1, wx.ID_ANY)
        self.CreateTreeCtrl(tree=self.tree_ctrl_1)
        self.window_1_pane_2 = wx.Panel(self.window_1, wx.ID_ANY)
        self.notebook_1 = wx.Notebook(self.window_1_pane_2, wx.ID_ANY)
        self.notebook_1_pane_2 = wx.Panel(self.notebook_1, wx.ID_ANY)
        self.button_1 = wx.Button(self.notebook_1_pane_2, wx.ID_ANY, u"绘图")
        self.window_2 = matplotlib_canvas.MatplotlibCanvas(self.notebook_1_pane_2, wx.ID_ANY)
        self.notebook_1_pane_3 = wx.Panel(self.notebook_1, wx.ID_ANY)
        self.window_3 = wx.SplitterWindow(self.notebook_1_pane_3, wx.ID_ANY)
        self.window_3_pane_1 = wx.ScrolledWindow(self.window_3, wx.ID_ANY, style=wx.TAB_TRAVERSAL)
        self.choice_1 = wx.Choice(self.window_3_pane_1, wx.ID_ANY, choices=[])
        self.client = pymongo.MongoClient(host='192.168.2.232', port=27017)
        # 密码认证
        self.client.admin.authenticate('nego', '123456abcd.')
        db_names = self.get_db_names()
        self.choice_1.AppendItems(db_names)
        self.choice_2 = wx.Choice(self.window_3_pane_1, wx.ID_ANY, choices=[])
        self.text_ctrl_1 = wx.TextCtrl(self.window_3_pane_1, wx.ID_ANY, "")
        self.text_ctrl_2 = wx.TextCtrl(self.window_3_pane_1, wx.ID_ANY, "")
        self.text_ctrl_3 = wx.TextCtrl(self.window_3_pane_1, wx.ID_ANY, "")
        self.text_ctrl_4 = wx.TextCtrl(self.window_3_pane_1, wx.ID_ANY, "")
        self.button_2 = wx.Button(self.window_3_pane_1, wx.ID_ANY, u"查询")
        self.list_box_1 = wx.ListBox(self.window_3_pane_1, wx.ID_ANY, choices=[])
        self.list_box_2 = wx.ListBox(self.window_3_pane_1, wx.ID_ANY, choices=[])
        self.radio_box_1 = wx.RadioBox(self.window_3_pane_1, wx.ID_ANY, u"类型", choices=[u"时域", u"频域"], majorDimension=1, style=wx.RA_SPECIFY_ROWS)
        self.button_3 = wx.Button(self.window_3_pane_1, wx.ID_ANY, u"绘图")
        self.window_3_pane_2 = wx.Panel(self.window_3, wx.ID_ANY)
        self.window_4 = matplotlib_canvas.MatplotlibCanvas(self.window_3_pane_2, wx.ID_ANY)
        self.toolbar = NavigationToolbar2WxAgg(self.window_4)
        self.toolbar.Hide()

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_TOOL, self.toolbar_home, id=1001)
        self.Bind(wx.EVT_TOOL, self.toolbar_back, id=1002)
        self.Bind(wx.EVT_TOOL, self.toolbar_forward, id=1003)
        self.Bind(wx.EVT_TOOL, self.toolbar_pan, id=1004)
        self.Bind(wx.EVT_TOOL, self.toolbar_zoom, id=1005)
        self.Bind(wx.EVT_TREE_SEL_CHANGING, self.ontree_ctrl_1, self.tree_ctrl_1)
        self.Bind(wx.EVT_BUTTON, self.onbutton_1, self.button_1)
        self.Bind(wx.EVT_CHOICE, self.onchoice_1, self.choice_1)
        self.Bind(wx.EVT_BUTTON, self.onbutton_2, self.button_2)
        self.Bind(wx.EVT_BUTTON, self.onbutton_3, self.button_3)
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: MyFrame.__set_properties
        self.SetTitle(u"北京能高普康")
        self.frame_statusbar.SetStatusWidths([-1])

        # statusbar fields
        frame_statusbar_fields = [u"欢迎使用！"]
        for i in range(len(frame_statusbar_fields)):
            self.frame_statusbar.SetStatusText(frame_statusbar_fields[i], i)
        self.frame_toolbar.Realize()
        self.window_1_pane_1.SetScrollRate(10, 10)
        self.radio_box_1.SetSelection(0)
        self.window_3_pane_1.SetScrollRate(10, 10)
        self.window_3.SetMinimumPaneSize(100)
        self.window_1.SetMinimumPaneSize(100)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MyFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.VERTICAL)
        sizer_5 = wx.BoxSizer(wx.VERTICAL)
        sizer_7 = wx.BoxSizer(wx.VERTICAL)
        sizer_6 = wx.BoxSizer(wx.VERTICAL)
        sizer_4 = wx.BoxSizer(wx.VERTICAL)
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_2.Add(self.tree_ctrl_1, 1, wx.EXPAND, 0)
        self.window_1_pane_1.SetSizer(sizer_2)
        sizer_4.Add(self.button_1, 0, wx.BOTTOM | wx.TOP, 10)
        sizer_4.Add(self.window_2, 1, wx.EXPAND, 0)
        self.notebook_1_pane_2.SetSizer(sizer_4)
        sizer_6.Add(self.choice_1, 0, wx.TOP, 10)
        sizer_6.Add(self.choice_2, 0, wx.TOP, 10)
        sizer_6.Add(self.text_ctrl_1, 0, wx.TOP, 10)
        sizer_6.Add(self.text_ctrl_2, 0, wx.TOP, 10)
        sizer_6.Add(self.text_ctrl_3, 0, wx.TOP, 10)
        sizer_6.Add(self.text_ctrl_4, 0, wx.TOP, 10)
        sizer_6.Add(self.button_2, 0, wx.TOP, 10)
        sizer_6.Add(self.list_box_1, 0, wx.TOP, 10)
        sizer_6.Add(self.list_box_2, 0, wx.TOP, 10)
        sizer_6.Add(self.radio_box_1, 0, wx.TOP, 10)
        sizer_6.Add(self.button_3, 0, wx.TOP, 10)
        self.window_3_pane_1.SetSizer(sizer_6)
        sizer_7.Add(self.window_4, 1, wx.EXPAND, 0)
        self.window_3_pane_2.SetSizer(sizer_7)
        self.window_3.SplitVertically(self.window_3_pane_1, self.window_3_pane_2, 200)
        sizer_5.Add(self.window_3, 1, wx.EXPAND, 0)
        self.notebook_1_pane_3.SetSizer(sizer_5)
        self.notebook_1.AddPage(self.notebook_1_pane_2, u"绘图测试")
        self.notebook_1.AddPage(self.notebook_1_pane_3, u"风机数据绘图")
        sizer_3.Add(self.notebook_1, 1, wx.EXPAND, 0)
        self.window_1_pane_2.SetSizer(sizer_3)
        self.window_1.SplitVertically(self.window_1_pane_1, self.window_1_pane_2, 200)
        sizer_1.Add(self.window_1, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        # end wxGlade

    def hello(self, event):  # wxGlade: MyFrame.<event_handler>
        wx.MessageBox('芳芳，我爱你！（づ￣3￣）づ╭❤～', '❤')
        event.Skip()

    def about(self, event):  # wxGlade: MyFrame.<event_handler>
        wx.MessageBox('爱你的车车', '关于')
        event.Skip()

    def toolbar_home(self, event):  # wxGlade: MyFrame.<event_handler>
        self.toolbar.home()
        print("Event handler 'toolbar_home' not implemented!")
        event.Skip()

    def toolbar_back(self, event):  # wxGlade: MyFrame.<event_handler>
        self.toolbar.back()
        print("Event handler 'toolbar_back' not implemented!")
        event.Skip()

    def toolbar_forward(self, event):  # wxGlade: MyFrame.<event_handler>
        self.toolbar.forward()
        print("Event handler 'toolbar_forward' not implemented!")
        event.Skip()

    def toolbar_pan(self, event):  # wxGlade: MyFrame.<event_handler>
        self.toolbar.pan()
        print("Event handler 'toolbar_pan' not implemented!")
        event.Skip()

    def toolbar_zoom(self, event):  # wxGlade: MyFrame.<event_handler>
        self.toolbar.zoom()
        print("Event handler 'toolbar_zoom' not implemented!")
        event.Skip()

    def ontree_ctrl_1(self, event):  # wxGlade: MyFrame.<event_handler>
        item = event.GetItem()
        wx.MessageBox(self.tree_ctrl_1.GetItemText(item))
        event.Skip()

    def onbutton_1(self, event):  # wxGlade: MyFrame.<event_handler>
        self.draw_demo(parent=self.window_2)
        event.Skip()

    def onchoice_1(self, event):  # wxGlade: MyFrame.<event_handler>
        # 先清空m_choice2
        self.choice_2.Clear()
        dbname = self.choice_1.GetStringSelection()
        db = self.client[dbname]
        collection = [c for c in db.list_collection_names() if c not in ['information', 'eigenvalue']]
        collection.sort()
        self.choice_2.AppendItems(collection)
        event.Skip()

    def onbutton_2(self, event):  # wxGlade: MyFrame.<event_handler>
        # 查询按钮

        dbname = self.choice_1.GetStringSelection()
        db = self.client[dbname]
        collection = self.choice_2.GetStringSelection()
        from_time = self.text_ctrl_1.GetValue()
        to_time = self.text_ctrl_2.GetValue()
        from_rotate_speed = self.text_ctrl_3.GetValue()
        to_rotate_speed = self.text_ctrl_4.GetValue()

        # 测点信息
        point_description = db['information'].find_one({'desc': '机组信息'})['point_description']
        # 对字典根据键值分组进行排序
        point_description = sorted(point_description.items(), key=lambda x: (x[0].split('_')[0], int(x[0].split('_')[1])))
        point_description = [x[1] for x in point_description]

        # 转速
        rotate_speed = db['information'].find_one({'desc': '机组信息'})['rotate_speed'][collection]

        rs = pd.DataFrame(rotate_speed.items())

        if from_time != '' and to_time != '' and from_rotate_speed != '' and to_rotate_speed != '':
            from_rotate_speed = float(from_rotate_speed)
            to_rotate_speed = float(to_rotate_speed)
            rs = rs[(rs.iloc[:, 0] >= from_time) & (rs.iloc[:, 0] <= to_time)]
            rs = rs[(rs.iloc[:, 1] >= from_rotate_speed) & (rs.iloc[:, 1] <= to_rotate_speed)]

        sampling_time = (rs.iloc[:, 0] + ':转速 ' + rs.iloc[:, 1].astype('str')).tolist()
        sampling_time = sorted(sampling_time, key=lambda x: x.split(':')[0], reverse=True)

        self.list_box_1.Clear()
        self.list_box_2.Clear()
        self.list_box_1.AppendItems(point_description)
        self.list_box_2.AppendItems(sampling_time)
        event.Skip()

    def onbutton_3(self, event):  # wxGlade: MyFrame.<event_handler>
        # 绘图按钮

        dbname = self.choice_1.GetStringSelection()
        db = self.client[dbname]
        collection = self.choice_2.GetStringSelection()
        sampling_time = self.list_box_2.GetStringSelection()
        sampling_time = sampling_time.split(':')[0]
        # 当前选中测点的中文描述
        point_zh = self.list_box_1.GetStringSelection()
        # 获取时域频域包络复选框的选中状态
        ts_checked = self.radio_box_1.GetSelection()
        freq_checked = self.radio_box_1.GetSelection()
        # env_checked = request.form.get('env_checked')

        # if env_checked:
            # low_cutoff = request.form.get('low_cutoff')
            # high_cutoff = request.form.get('high_cutoff')
            # if low_cutoff != '' and high_cutoff != '':
                # low_cutoff = float(low_cutoff)
                # high_cutoff = float(high_cutoff)
        # else:
            # low_cutoff = ''
            # high_cutoff = ''

        # 测点信息
        point_description = db['information'].find_one({'desc': '机组信息'})['point_description']
        # 当前选中测点的中文描述对应的数据库中的键
        point = [key for key in point_description if point_description[key] == point_zh][0]
        point_num = point.split('_')[-1]

        data = db[collection].find_one({'sampling_time': sampling_time})

        # 采样频率
        sampling_fre = 0

        # 时域数据
        time_series = []
        # 频域数据
        freq = []
        # 频谱包络数据
        envelope_spectrum = []

        try:
            if 'drivechain_' in point:
                if 'data_length_drivechain' in data.keys():
                    data_length = data['data_length_drivechain']
                    sampling_fre = data['sampling_fre_drivechain']
                elif int(point_num) < 6:
                    data_length = data['data_length_drivechain_15']
                    sampling_fre = data['sampling_fre_drivechain_15']
                else:
                    data_length = data['data_length_drivechain_68']
                    sampling_fre = data['sampling_fre_drivechain_68']
            elif 'tower_' in point:
                data_length = data['data_length_tower']
                sampling_fre = data['sampling_fre_tower']
            elif 'nacelle_' in point:
                data_length = data['data_length_nacelle']
                sampling_fre = data['sampling_fre_nacelle']
            elif 'blade_' in point:
                data_length = data['data_length_blade']
                sampling_fre = data['sampling_fre_blade']
            else:
                if int(point_num) < 6:
                    data_length = data['data_nums_15'][0]
                    sampling_fre = data['sampling_fre_15']
                else:
                    data_length = data['data_nums_68'][0]
                    sampling_fre = data['sampling_fre_68']

            data = struct.unpack(str(data_length) + 'f', data[point])
            data = pd.Series(data)
            data = data.round(decimals=6)

            if ts_checked == 0:
                # time series
                # for v in zip(range(len(data)), data):
                #     time_series.append(v)

                time_series = data.tolist()

            if freq_checked == 1:
                # freq
                fre, am = self.fourier_transform(data, sampling_fre)
                am = pd.Series(am)
                am = am.round(decimals=6)

                freq.append(fre.tolist())
                freq.append(am.tolist())

            if env_checked:
                # envelope spectrum
                if low_cutoff != '' and high_cutoff != '':
                    fre, am, _ = self.envelop(data, sampling_fre, low_cutoff, high_cutoff)
                    am = pd.Series(am)
                    am = am.round(decimals=6)

                    envelope_spectrum.append(fre.tolist())
                    envelope_spectrum.append(am.tolist())

        except Exception as e:
            print(e)

        dataset = dict()
        dataset['fs'] = sampling_fre
        dataset['time_series'] = time_series
        dataset['freq'] = freq
        dataset['envelope'] = envelope_spectrum[:500]

        if ts_checked == 0:
            self.tfe(parent=self.window_4, data=[range(len(dataset['time_series'])), dataset['time_series']])

        if freq_checked == 1:
            self.tfe(parent=self.window_4, data=dataset['freq'])
        event.Skip()

    def CreateTreeCtrl(self, parent=None, tree=None):
        # tree = wx.TreeCtrl(parent)
        tree = tree
        # 通过wx.ImageList()创建一个图像列表imglist并保存在树中
        imglist = wx.ImageList(16, 16, True, 2)
        imglist.Add(wx.ArtProvider.GetBitmap(wx.ART_FOLDER, size=wx.Size(16, 16)))
        imglist.Add(wx.ArtProvider.GetBitmap(wx.ART_NORMAL_FILE, size=(16, 16)))
        tree.AssignImageList(imglist)
        # 创建根节点和5个子节点并展开
        root = tree.AddRoot('TreeRoot', image=0)
        item1 = tree.AppendItem(root, 'Item1', 0)
        item2 = tree.AppendItem(root, 'Item2', 0)
        item3 = tree.AppendItem(root, 'Item3', 0)
        item4 = tree.AppendItem(root, 'Item4', 0)
        item5 = tree.AppendItem(root, 'Item5', 0)
        tree.Expand(root)
        tree.SelectItem(root)
 
        # 给item1节点添加5个子节点并展开
        tree.AppendItem(item1, 'file 1', 1)
        tree.AppendItem(item1, 'file 2', 1)
        tree.AppendItem(item1, 'file 3', 1)
        tree.AppendItem(item1, 'file 4', 1)
        tree.AppendItem(item1, 'file 5', 1)
        tree.Expand(item1)
 
        # 给item2节点添加5个子节点并展开
        tree.AppendItem(item2, 'file 1', 1)
        tree.AppendItem(item2, 'file 2', 1)
        tree.AppendItem(item2, 'file 3', 1)
        tree.AppendItem(item2, 'file 4', 1)
        tree.AppendItem(item2, 'file 5', 1)
        tree.Expand(item2)
 
        # 返回树对象
        return tree

    def get_db_names(self):
        to_remove = ['admin', 'config', 'local', 'management']
        db_names = [db for db in self.client.list_database_names() if db not in to_remove]

        return db_names

    # ******频谱计算函数******
    def filter_data(self, data, fs, low_cut, high_cut):
        d = np.array(data)
        n = len(d)
        df = fs / n
        n_low_cut = round(low_cut / df)
        n_high_cut = round(high_cut / df)
        ft = fft(d)
        ft[0:n_low_cut] = 0 + 0j
        ft[-n_low_cut:n] = 0 + 0j
        ft[n_high_cut:-n_high_cut] = 0 + 0j
        filtered_data = ifft(ft).real
        return filtered_data

    def fourier_transform(self, data, fs):
        d = np.array(data)
        n = len(d)
        df = fs / n
        ft = fft(d)
        ft = abs(ft) * 2 / n
        am = ft[0:int(np.round(n / 2))]
        fre = np.arange(int(np.round(n / 2))) * df
        return fre, am

    def envelop(self, data, fs, low_cutoff, high_cutoff):
        filtered_data = self.filter_data(data, fs, low_cutoff, high_cutoff)
        hx = hilbert(filtered_data)
        x = np.sqrt(filtered_data ** 2 + hx ** 2)
        x = x - np.mean(x)
        fre, am = self.fourier_transform(x, fs)
        return fre, am, x
    # ******频谱计算函数******

    def draw_demo(self, parent):
        canvas = parent.axes
        canvas.cla()
        canvas.grid(True, color="grey", linestyle='--')
        
        #参数为一个list
        y = np.random.randint(10, size=100)
        len_y = len(y)
        x = range(len_y)
        _y = [y[-1]]*len_y
        
        # fig = plt.figure(figsize=(960/72,360/72))
        fig = parent.figure
        # ax1 = fig.add_subplot(1,1,1)
        ax1 = canvas
        
        ax1.plot(x, y, color='blue')
        line_x = ax1.plot(x, _y, color='skyblue')[0]
        line_y = ax1.axvline(x=len_y-1, color='skyblue')
        
        ax1.set_title('')
        #标签
        # text0 = plt.text(len_y-1,y[-1],str(y[-1]),fontsize = 10)
        text0 = ax1.text(len_y-1,y[-1],str(y[-1]),fontsize = 10)
        
        def scroll(event):
            axtemp=event.inaxes
            x_min, x_max = axtemp.get_xlim()
            fanwei_x = (x_max - x_min) / 10
            if event.button == 'up':
                axtemp.set(xlim=(x_min + fanwei_x, x_max - fanwei_x))
            elif event.button == 'down':
                axtemp.set(xlim=(x_min - fanwei_x, x_max + fanwei_x))
            fig.canvas.draw_idle() 
        #这个函数实时更新图片的显示内容
        def motion(event):
            try:
                temp = y[int(np.round(event.xdata))]
                for i in range(len_y):
                    _y[i] = temp
                line_x.set_ydata(_y)
                line_y.set_xdata(event.xdata)
                ######
                text0.set_position((event.xdata, temp))
                text0.set_text(str(temp))
                
                fig.canvas.draw_idle() # 绘图动作实时反映在图像上
            except:
                pass

        fig.canvas.mpl_connect('scroll_event', scroll)
        fig.canvas.mpl_connect('motion_notify_event', motion)
        parent.draw()

    def tfe(self, parent, data):
        canvas = parent.axes
        canvas.cla()
        canvas.grid(True, color="grey", linestyle='--')

        #参数为一个list
        y = data[1]
        len_y = len(y)
        x = data[0]
        _y = [y[-1]]*len_y
        
        fig = parent.figure
        ax1 = canvas
        
        ax1.plot(x, y, color='blue', linewidth=0.5)
        ax1.set_xlim(xmax=max(x))
        line_x = ax1.plot(x, _y, color='skyblue')[0]
        line_y = ax1.axvline(x=len_y-1, color='skyblue')
        
        ax1.set_title('')
        #标签
        text0 = ax1.text(len_y-1,y[-1],str(y[-1]),fontsize = 10)
        
        def scroll(event):
            axtemp=event.inaxes
            x_min, x_max = axtemp.get_xlim()
            fanwei_x = (x_max - x_min) / 10
            if event.button == 'up':
                axtemp.set(xlim=(x_min + fanwei_x, x_max - fanwei_x))
            elif event.button == 'down':
                axtemp.set(xlim=(x_min - fanwei_x, x_max + fanwei_x))
            fig.canvas.draw_idle() 
        #这个函数实时更新图片的显示内容
        def motion(event):
            try:
                temp = y[int(np.round(event.xdata))]
                for i in range(len_y):
                    _y[i] = temp
                line_x.set_ydata(_y)
                line_y.set_xdata(event.xdata)
                ######
                text0.set_position((event.xdata, temp))
                text0.set_text(str(temp))
                
                fig.canvas.draw_idle() # 绘图动作实时反映在图像上
            except:
                pass

        fig.canvas.mpl_connect('scroll_event', scroll)
        fig.canvas.mpl_connect('motion_notify_event', motion)
        parent.draw()

# end of class MyFrame

class MyApp(wx.App):
    def OnInit(self):
        self.frame = MyFrame(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame)
        self.frame.Show()
        return True

# end of class MyApp

if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
